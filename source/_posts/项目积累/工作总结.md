---
title: 工作总结
date: 2019-06-26 19:43:51
tags:
- todo
categories:
- 项目积累
---

# 工作总结



1、 隶属于个人的页面或功能必须进行权限控制校验

2、数据安全问题，脱敏

3、防止sql注入

4、分页参数 以及order by 有效性验证

5、表单、AJAX提交执行CSRF安全验证

CSRF 跨站请求伪造

6、资源要加防重放机制

  短信、邮箱、支付、第三方请求等

7、外部调用模块独立。不信任原则。调用要try-catch，有熔断策略等

8、代码利用StopWatch、Arthas等做详细分析；

9、简单一直是架构设计所追求的，在简单的前提下去满足不同的设计，一点点去增加复杂的



成长必须经历一个步骤，就是把知识内化成能力。**知识是用脑记住的，能力是用手练习出来的**。在工作的几年里，我们可能看过很多书，听过很多技术讲座和视频，但是通过听和看只是让你能记住这些知识，这些知识还不能转换成你的能力。

听和看只是第一步，更重要的是实践，通过刻意练习把听到和看到的知识内化成你的能力。

刻意练习，就是有目的的练习，先规划好，再去练习。首先给自己定一个目标，目标可以有效的引导你学习，然后使用3F练习法：

- 1： 专注（Focus），专注在眼前的任务上，在学习过程中保持专注，可以尝试使用番茄工作法。
- 2：反馈（Feedback），意识到自己的不足，学习完之后进行反思，思考下自己哪些方面不足，为什么不足，
- 3： 修正（Fix），改进自己的不足。

不停的练习和思考可以改变大脑结构，大脑像肌肉一样，挑战越大，影响越大，学习更高效，并且也会产生突破性。





开发和设计其实一直就是在妥协

首先目前我理解的开发实质就是 对 信息的传输、处理、保存和展示这几方面。开发就是一直在对这几个方面进行处理

- 提高传输的速度，保证传输的稳定性，不丢失
- 提高信息处理的速度
- 选择合适的存储结构保存信息，在合适的时候展示
- 提高信息的查询速度和保证查询的稳定性。
- 问题隔离

速度方面，首先想到的是多线程，通过多线程并发提高速度，不过使用了多线程就需要考虑 并发安全 、线程竞争、处理顺序、线程数量等问题。

稳定性方面，就是考虑备份的问题，一个挂了还有个备用的，所有的数据都有备份。所以在各个环节就出现了分布式概念，分布式存储、分部署部署。随着分布式而来的问题也就有了，复制问题、主从问题、存储浪费问题、负载均衡问题、失效重启问题。

所以开发其实就是一个制造问题和解决问题的死循环，很多时候就是两者的妥协。

问题隔离就是讲出问题的模块隔离开，不要影响正常的模块，代码的 try catch功能、mq的解耦、大接口拆分小接口都是在对问题进行隔离。

在开发设计中就是本着设计原则，用设计模式作为手段，具备底层的数据结构和算法基础然后去创造问题解决问题。

所有的中间件都是为了解决这些问题应运而生的。所以在设计中首先要去信赖组件能解决问题，然后在这个前提下再去考虑其他问题， 比如集群，都会去依赖zookeeper，那就认为使用zookeeper来做集群处理，至于zookeeper能不能解决，那是zookeeper的事，先在这个大前提下解决了其他问题，然后再去处理zookeeper存在的问题，让他没问题。

痛点 : 系统设计的边界感

- 设计原则目的:分离变化和不变，降低变化的影响，减少对原有逻辑的开发时间，比如说全量测试，很坑

- - 单一职责 :降低变化的理由
  - 接口隔离 :暴露的接口三天两头改，坑，降低变化的理由	
  - 最少知道 :门面模式、中介者模式
  - 里氏置换 : 父类能够代替子类，可以使用新的子类来替换，子类可以扩展父类的功能，但是不能改变父类原有的功能，也是开闭原则的体现
  - 开闭原则
  - 依赖倒转
  - 代码复用

在产品迭代中，需求是一直在变化的， 如果设计不好，直接会导致推翻重做，全量测试，一个是时间成本大，一个是风险大。如果在需求评审的时候，往多想一想，问一问，设计的时候考虑下不变的业务和变化的业务，将两者分离抽象。这样哪怕以后重做，重做的部分也是少部分，实现代码的重复利用，也减少测试、验收的时间，从而降低风险，提供系统的稳定性

开发和设计其实最主要的是弄明白，能给我什么，最终要的是什么，及入口变量和结果集。这两东西是一个面向对象设计的最重要的属性，而且基本不会变，变了的话就是一个新的东西。所以这个弄明白了，从入口到出口封装为一个个体，能够独立运行并且可以提供完善功能的个体，减少它的依赖，让它裸奔。小到一个方法、一个对象、一个接口、一个模块、一个工程，大到一个系统。把一个个能独立运行并提供特有功能的小个体不断组合，最终形成一个系统，这样的系统就会稳定，扩展性强

- 设计模式 是实现设计原则的一种手段，将继承关系更多的转变为组合关系

- - 命令模式: 分离命令的发出和执行。抽象命令，同时抽象命令的执行
  - 桥接模式 : 关联两个维度的变化
  - 模板模式: 分离变化和不变  委托模式的变体
  - 状态模式: 避免大量if else  将不同实现封装到不同状态对象里面去实现
  - 策略模式: 提现了开闭原则 接口隔离，也可以避免 if else
  - 装饰模式 VS 适配器模式 VS 责任链模式 : 都是对象组合关系  ，适配器接口比装饰模式接口宽
  - 装饰模式应用场景 流  类型转换器 Converter  抽象装饰器
  - 访问者模式: 变化的是访问者，不变的是被访问者 跟策略模式好像

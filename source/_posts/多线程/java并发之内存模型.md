---
title: java并发之内存模型
date: 2020-08-01
tags:
- 多线程
categories:
- java基础
---

# java并发之内存模型

## 知识导读

- 注意  加锁并不能解决重排序问题

## 问题背景

1. 缓存一致性问题

   计算机为了提高读写速度，在每个处理器和内存之间加了几层高速缓存，每个处理器运算时将内存中的数据复制到自己的高速缓存中，运算结束再将自己高速缓存的数据同步回内存中，这样提高了内存的读写效率。

   在提高效率的同时，由于每个处理器都有自己的高速缓存，从而导致了缓存一致性问题。内存模型就是在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象，不同架构的机器可能有不一样的内存模型

2. 优化重排序

   为了使处理器内部的运算单元能尽量被充分利用，提高程序执行效率，java编译器和处理器都可能都不存在数据依赖关系的指令进行重排序，重排序后的程序只能保证**单线程**环境的执行结果正确

   重排序分3种类型。

   1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

   2. 指令级并行的重排序。现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。

      加载add(b,c)需要先加载完b和c。为了减少停顿，可以在加载b和c的同时加载e和f

         ```java
      a = b + c; 
         d = e - f ;
         ```
   
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
   

**注意：**编译器和处理器都不会改变存在数据依赖关系的两个操作的执行顺序，保证单线程环境下程序能够得出正确的执行结果

**可见性：** 指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。保证线程每次使用共享变量时都去主内存获取最新的，保证了read-load的一致性

**原子性：** 指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。保证线程在read-load-use-assign-store-write共享变量过程中，其它线程不能对主内存的共享变量进行修改，这时就需要lock主内存的变量，操作完毕后unlock

**有序性**: 由于编译器和处理器对指令的优化重排序，导致程序指令可能不会按照编程人员的要求顺序执行

## JMM

并发编程需要处理两个关键问题

- 线程之间如何通信以及如何进行信息交换
- 线程之间如何同步,保证多线程之间操作的相对顺序

线程之间的通信机制有两种:共享内存和消息传递。

### 定义

JMM屏蔽了不同处理器内存模型的差异，为Java程序员呈现了一个一致的内存模型。JMM规定线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本，各个线程线程只能访问自己的工作内存，不可以访问其它线程的工作内存。

**注意：**线线本地内存是JMM的 一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

JMM定义了线程和主内存之间的抽象关系，JMM规定了对共享变量的写入操作在何时将对其他线程可见。

设计JMM时的核心目标就是找到一个 好的平衡点:一方面，要为程序员提供足够强的内存可见性保证;另一方面，对编译器和处理器的限制要尽可能地放松，竟可能的让其优化程序



![JHyhHl](https://raw.githubusercontent.com/aspiresnow/aspiresnow.github.io/hexo/source/blog_images/2020/08/JHyhHl.png)

从图可以得出结论

1. 所有的共享变量都存在主内存中
2. 每个线程在自己的工作内存中保存一份共享变量的副本
3. 线程对共享变量的所有操作必须在自己的本地内存中进行，不能直接从主内存读写
4. 线程只能访问自己的本地内存或者主内存，不能访问其他线程的本地内存

### 内存交互

JMM定义了8个操作来完成共享变量从主内存和工作内存的交互细节

![image](https://github.com/aspiresnow/aspiresnow.github.io/blob/hexo/source/blog_images/%E5%B9%B6%E5%8F%91/ts4.png?raw=true)
									`java中线程工作内存跟主内存的交互`

JMM规定了工作内存与主内存之间交互的协议，首先是定义了8种原子操作：

1. lock:将主内存中的变量锁定，为一个线程所独占，使用syncronize或者lock的时候
2. unclock:将lock加的锁定解除，此时其它的线程可以有机会访问此变量，释放锁
3. read:将主内存中的变量值传输到线程的工作内存当中，随后的load动作使用
4. load:将线程工作内存中的变量指向上个read动作读取到的值。
5. use:将值传递给线程的代码执行引擎(多次)
6. assign:将执行引擎处理返回的值重新赋值给变量副本
7. store:将变量副本的值存储到主内存中。
8. write:将主内存的共享变量指向上个store动作存储的值。

Java内存模型也针对这些操作指定了必须满足的规则:

1. read和load、store和write必须要成对出现，不允许单一的操作，否则会造成从主内存读取的值，工作内存不接受或者工作内存发起的写入操作而主内存无法接受的现象。
2. 在线程中使用了assign操作改变了变量副本，那么就必须把这个副本通过store-write同步回主内存中。如果线程中没有发生assign操作，那么也不允许使用store-write同步到主内存。
3. 在对一个变量实行use和store操作之前，必须实行过load和assign操作。
4. 变量在同一时刻只允许一个线程对其进行lock,有多少次lock操作，就必须有多少次unlock操作。在lock操作之后会清空此变量在工作内存中的副本，需要再次从主内存read-load新的值。在执行unlock操作前，需要把改变的副本同步回主存。

### 重排序

```java
//线程1初始化User
User user;
user = new User();
//线程2读取user
if(user!=null){
	user.getName();
}
```

User user = new User()包括了以下三种语义：
1：memory = allocate();//分配对象的内存空间
2：ctorInstance(memory);  // 2:初始化对象初始化对象
3：instance = memory;//将user指针指向刚分配的内存地址

操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM是可以针对它们进行指令的优化重排序的，优化后变为 1->3->2，这些线程1在执行完第3步而还没来得及执行完第2步的时候，如果内存刷新到了主存，那么线程2将得到一个未初始化完成的对象。

#### as-if-serial

**as-if-serial**语义保证**单线程**情况下程序执行结果不能被改变，无论编译器和处理器怎么重排序

为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被 编译器和处理器重排序

例如下面代码，A和B相互之间没有依赖关系，可以重排序，C依赖A和B的结果，所以A和C、B和C之间都不可以重排序

```java
double pi = 3.14; // A 
double r = 1.0; // B 
double area=pi*r*r; //C
```

### happens-before

由于指令存在重排序问题，as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。

happens-before规则提出是为了方便编程人员更好的理解JMM对于重排序的处理，在happens-before规则指导下进行多线程编程

- 程序次序规则（Program Order Rule）：**单线程**有序性保证，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循 环等结构。

- 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这 里必须强调的是“同一个锁”，而“后面”是指时间上的先后。

- volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量 的读操作，这里的“后面”同样是指时间上的先后。

- 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。 
- 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止 执行。

- 线程中断规则（Thread Interruption Rule）：要先通过线程interrupt()方法发出中断信号，线程才可以通过Thread::interrupted()方法检测到是否有中断发生。

- 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。

- 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出 操作A先行发生于操作C的结论。

## 同步原语

### synchronized

synchronized保证了同步代码块中代码的内存可见性和原子性，**但是并不解决有序性**

- 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，同步代码块必须去主内存读取所需的共享变量。
- 当线程释放锁时，JMM会将当前线程工作内存中的共享变量刷新到主内存中

### volatile

volatile关键字用于修饰一个变量，被volatile修饰的变量实现了一些特殊含义

- 保证了volatile修饰的变量的内存可见性
- 防止变量前后指令重排，保证了有序性
- **不能解决原子性**

volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

#### 内存可见性

volatile的内存语义

- 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，必须从主 内存中读取共享变量。
- 当写一个volatile变量时，JMM会把该线程工作内存中的共享变量值刷新到主内 存。

只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量 V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现。

这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其 他线程对变量V所做的修改。

只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程 T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出 现。

这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以 看到自己对变量V所做的修改。

·假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动 作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W 实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的 对变量W的read或write动作。如果A先于B，那么P先于Q。

这条规则要求volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。

#### 有序性

为了实现volatile内存语义，JMM 会分别限制这两种类型的重排序类型

- 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。 
- 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。

- 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

#### 不保证原子性

例如一个被volatile修饰的int变量，100个线程同时执行 i++变量，最后i的值并不等于100，会得到一个小于100的值。

```java
public volatile int i = 0;
public void increase() {
  i++;
}
```

对于volatile修饰的变量，并不能保证变量读写操作的原子性，i++可以拆成3个操作，无法保证这3个操作的原子性

```java
i=i;//从主存读取变量到工作内存
i+1;//修改i值
i=i;//将值写回主存
```

volatile修饰后只能保证每次去主存读取变量，修改完毕后写回主存。另外一个线程可能会在该线程写回主存前读取到老的值，修改后再覆盖主存的值，所以最终导致i是一个小于100的值。

#### 实现原理

使用volatile后，会在该变量指令前后加入一个内存屏障，用于实现对内存操作的顺序限制。保证在volatile修饰的变量指令前的指令行无论顺序怎么变一定在volatile变量前全部执行，在volatile变量指令后的指令行无论顺序怎么变，都一定在volatile变量指令执行完后才执行。

硬件层面，内存屏障分读屏障和写屏障。内存屏障主要有两个作用

1. 阻塞屏障两侧的指令重排序
2. 强制把写缓冲区中的脏数据写回主内存，或者让缓存中相应的数据失效

编译器在生成字节码时，会在指令序列中插入内存屏障来 禁止特定类型的处理器重排序。

- 在每个volatile写操作的前面插入一个StoreStore屏障。
- 在每个volatile写操作的后面插入一个StoreLoad屏障。
- 在每个volatile读操作的后面插入一个LoadLoad屏障。
- 在每个volatile读操作的后面插入一个LoadStore屏障。

### final

两个重排序规则。

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能 重排序。





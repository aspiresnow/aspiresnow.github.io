---
title: java并发之内存模型
date: 2020-08-01
tags:
- 多线程
categories:
- java基础
---

# java并发之内存模型

注意  加锁并不能解决重排序问题？？？？

JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现 了一个一致的内存模型。

设计JMM时的核心目标就是找到一个 好的平衡点:一方面，要为程序员提供足够强的内存可见性保证;另一方面，对编译器和处理器的限制要尽可能地放松，竟可能的让其优化程序

JMM其实是在遵 循一个基本原则:只要不改变程序的执行结果(指的是单线程程序和正确同步的多线程程序)， 编译器和处理器怎么优化都行

Java内存模型的设计，主要介绍Java内存模型的设计原理，及其与处理器内存模型和顺序一致性内存模型的关系。



在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态 进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消 息来显式进行通信。

同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型 里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。 在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的



Java线程之间的通信由Java内存模型(本文简称为JMM)控制，JMM决定一个线程对共享 变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽 象关系:线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地 内存(Local Memory)，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的 一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优 化

本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时，这3个 内存中的x值都为0。线程A在执行时，把更新后的x值(假设值为1)临时存放在自己的本地内存 A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内 存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时 线程B的本地内存的x值也变为了1。

从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要 经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供 内存可见性保证。

## 知识导读

## 解决问题

并发编程需要处理两个关键问题

- 线程之间如何通信以及如何进行信息交换

- 线程之间如何同步,保证多线程之间操作的相对顺序

  

线程之间的通信机制有两种:共享内存和消息传递。

java线程之间的通信由JMM控制，JMM定义了线程和主内存之间的抽象关系

![JHyhHl](https://raw.githubusercontent.com/aspiresnow/aspiresnow.github.io/hexo/source/blog_images/2020/08/JHyhHl.png)

从图可以得出结论

1. 所有的共享变量都存在主内存中
2. 每个线程在自己的工作内存中保存一份共享变量的副本
3. 线程对共享变量的所有操作必须在自己的本地内存中进行，不能直接从主内存读写
4. 线程只能访问自己的本地内存或者主内存，不能访问其他线程的本地内存
5. 线程A和线程B之间的通信
   1. 线程A将本地内存更新过的共享变量刷新到主内存中
   2. 线程B从主内存中读取线程A修改后的结果，然后在本地内存创建共享变量的副本

如何实现共享变量被修改后其他线程能够感知到呢，JMM通过控制主内存和每个线程的本地内存之间的交互，实现了内存可见性

### 顺序一致性

顺序一致性内存模型有两大特性。

1)一个线程中的所有操作必须按照程序的顺序来执行。

2)(不管程序是否同步)所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内 存模型中，每个操作都必须原子执行且立刻对所有线程可见。

### 重排序

为什么指令重排序可以提高性能?每个指令都包含多个步骤，每个步骤可能会使用不同的硬件。因此流水线技术产生了，原理是指令1还没执行完，就开始执行指令2，而不用等到指令1执行结束再去执行指令2，这样就能提高效率。流水线最害怕中断，恢复中断的代价比较大，指令重排就是减少中断的一种技术

```java
a = b + c; 
d = e - f ;
```

加载add(b,c)需要先加载完b和c。为了减少停顿，可以在加载b和c的同时区加载e和f

重排序分3种类型。

1)编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2)指令级并行的重排序。现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。

3)内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序 出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排 序(不是所有的编译器重排序都要禁止)。对于处理器重排序，JMM的处理器重排序规则会要 求Java编译器在生成指令序列时，插入特定类型的内存屏障(Memory Barriers，Intel称之为 Memory Fence)指令，通过内存屏障指令来禁止特定类型的处理器重排序。

JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作， 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

#### as-if-serial

as-if-serial语义的意思是:不管怎么重排序，**单线程**程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。

为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因 为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被 编译器和处理器重排序

A和B相互之间没有依赖关系，可以重排序，C依赖A和B的结果，所以A和C、B和C直接都不可以重排序

```java
double pi = 3.14; // A 
double r = 1.0; // B 
double area=pi*r*r; //C
```



### happens-before

·as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同 步的多线程程序的执行结果不被改变。

happens-before是JMM通过制定和禁止各种重排序从而达到的一种结果，happens-before规则是为了方便程序员理解JMM，程序员只要遵循happens-before规则，写的程序就能保证在JMM中具有内存可见性，从而保证指令在多线程之间运行结果符合程序员的预期。

![bvmGLT](https://raw.githubusercontent.com/aspiresnow/aspiresnow.github.io/hexo/source/blog_images/2020/08/bvmGLT.png)

JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一 个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关 系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行!happens-before仅仅要求前一个操作(执行的结果)对后一个操作可见，且前一 个操作按顺序排在第二个操作之前

## 同步原语

### synchronized

保证了了内存可见性和原子性

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中

当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的 临界区代码必须从主内存中读取共享变量

### volatile

保证了内存可见性和有序性

理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步，轻量级锁

锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对 一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。

·可见性。对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。

·原子性:对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不 具有原子性。

当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内 存。

当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主 内存中读取共享变量。

为了实现volatile内存语义，JMM 会分别限制这两种类型的重排序类型

- 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。 
- 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。

- 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

硬件层面，内存屏障分读屏障和写屏障。内存屏障主要有两个作用

1. 阻塞屏障两侧的指令重排序
2. 强制把写缓冲区中的脏数据写回主内存，或者让缓存中相应的数据失效

编译器在生成字节码时，会在指令序列中插入内存屏障来 禁止特定类型的处理器重排序。

- 在每个volatile写操作的前面插入一个StoreStore屏障。
- 在每个volatile写操作的后面插入一个StoreLoad屏障。
- 在每个volatile读操作的后面插入一个LoadLoad屏障。
- 在每个volatile读操作的后面插入一个LoadStore屏障。



### final

两个重排序规则。

1)在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

2)初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能 重排序。





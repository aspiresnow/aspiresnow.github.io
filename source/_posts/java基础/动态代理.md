---
title: 动态代理
date: 2017-10-15 22:23:36
tags:
- spring
categories:
- java基础
---

# 动态代理

> 代理的实质是在运行期间手动创建class类，对被代理对象的方法进行代理，调用被代理对象的方法，动态代理就是动态的创建Proxy对象，用完之后销毁class类，避免冗杂，动态代理的实现方式主要有以下两种。
> CGLIB代理主要是对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。

<!--more-->

##### 一、通过jdk实现InvocationHandler实现动态代理
###### 1、定义接口
```
package cn.zlz.proxy.jdk;

public interface IComputorService {
	
	/**
	 * 卖电脑
	 * @param brand
	 */
	public void sellComputor(String brand);
	/**
	 * 修电脑
	 */
	public void repairComputor(String brand);

}
```
###### 2、定义接口实现类
```
package cn.zlz.proxy.jdk;

public class ThinkPadSeller implements IComputorService{

	public void sellComputor(String brand) {
		System.out.println("sell the thinkPad computor");
		
	}

	public void repairComputor(String brand) {
		System.out.println("repair the thinkPad computor");
	}

}
```
###### 3、定义生成代理对象
```
package cn.zlz.proxy.jdk;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class SimpleProxyImpl implements InvocationHandler {

	// 被代理对象
	private ThinkPadSeller thinkPadSeller;

	public SimpleProxyImpl(ThinkPadSeller thinkPadSeller) {
		super();
		this.thinkPadSeller = thinkPadSeller;
	}

	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		System.out.println("代理开始");
		// 调用被代理对象
		method.invoke(thinkPadSeller, args);
		System.out.println("代理结束");
		return null;
	}
    //提供方法获取代理对象  
    public IComputorService newProxy(){  
          
        //使用Proxy类创建代理对象  
    	IComputorService proxyInstance = (IComputorService) Proxy.newProxyInstance(thinkPadSeller.getClass().getClassLoader(), //使用被代理对象的加载器  
    			thinkPadSeller.getClass().getInterfaces(), //使用被代理对象的接口  
                this );//匿名内部类比较坑，所以我们找一个类实现并覆写方法，直接用本类，现成的..  
        return proxyInstance;  
    }  
}
```
###### 4、main函数测试
```
package cn.zlz.proxy.jdk;

import java.lang.reflect.Proxy;

/**
 *  通过jdk的实现invocationHandler接口只能代理实现接口的对象
 *  为了解决这个问题，就有了动态地创建Proxy的想法：在运行状态中，需要代理的地方，根据接口 和被代理对象，
 *  动态地创建一个Proxy，用完之后，就会销毁，这样就可以避免了Proxy 角色的class在系统中冗杂的问题了。
 *
 */
public class Main {

	public static void main(String[] args) {
		/**
		 * 使用Proxy创建代理对象
		 * 1、被代理对象
		 * 2、被代理对象实现的接口s
		 * 3、Invocation实现对象
		 */
		//使用Proxy类创建代理对象
		Class beProxyClazz = ThinkPadSeller.class;
		ThinkPadSeller thinkPadSeller = new ThinkPadSeller();
		ClassLoader classLoader = beProxyClazz.getClassLoader();
		Class[] interfaces = beProxyClazz.getInterfaces();
		SimpleProxyImpl simpleProxyImpl = new SimpleProxyImpl(thinkPadSeller);
		// 根据上面提供的信息，创建代理对象 在这个过程中，JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码 ,然后根据相应的字节码转换成对应的class,然后调用newInstance()创建实例 
		IComputorService proxy = (IComputorService) Proxy.newProxyInstance(classLoader, interfaces, simpleProxyImpl);
		/*
		 * 生成的代理对象编译后的代码为 public final repairComputor(){this.h.invoke(this, m3, null);m3 = Class.forName("cn.zlz.proxy.jdk.ThinkPadSeller").getMethod("repairComputor", [String.class]); }
		 * this指的是invocation的实现类，调用invoke方法，并将被代理对象的方法作为参数传递
		 */
		proxy.repairComputor("thinkPad");
	}
}
```
##### 而、通过cglib实现动态代理
###### 1、定义被代理对象
```
package cn.zlz.proxy.cglib;

public class ThinkPadSeller {

	public void sellComputor(String brand) {
		System.out.println("sell the thinkPad computor");

	}

	public void repairComputor(String brand) {
		System.out.println("repair the thinkPad computor");
	}

}
```
###### 2、实现cglib的MethodInterceptor
```
package cn.zlz.proxy.cglib;

import java.lang.reflect.Method;

import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

/*
 * cglib代理，实现MethodInterceptor
 */
public class CglibProxy implements MethodInterceptor {

	public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
		System.out.println("开始代理");
		//代理类是继承的被代理类，调用父类的原方法
		proxy.invokeSuper(obj, args);  
		
		System.out.println("结束代理");
		return null;
	}

}
```
###### 3、main函数调试
```
package cn.zlz.proxy.cglib;

import net.sf.cglib.proxy.Enhancer;

/*
 * 代理对象继承被代理对象
  1.查找被代理类的所有非final 的public类型的方法定义；
  2.将这些方法的定义转换成字节码；
  3.将组成的字节码转换成相应的代理的class对象；
  4.实现 MethodInterceptor接口，用来处理 对代理类上所有方法的请求（这个接口和JDK动态代理InvocationHandler的功能和角色是一样的）
 */
public class Main {
	public static void main(String[] args) {
		CglibProxy cglibProxy = new CglibProxy();
		// cglib 中加强器，用来创建动态代理
		Enhancer enhancer = new Enhancer();
		// 设置要创建动态代理的类,即父类
		enhancer.setSuperclass(ThinkPadSeller.class);
		// 设置回调，这里相当于是对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实行intercept()方法进行拦截
		enhancer.setCallback(cglibProxy);
		ThinkPadSeller proxy = (ThinkPadSeller) enhancer.create();
		proxy.repairComputor("thinkpad");
	}
}
```
## 参考

[Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）](http://blog.csdn.net/luanlouis/article/details/24589193)



​	
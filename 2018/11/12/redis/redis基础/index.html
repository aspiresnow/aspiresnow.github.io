<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          redis基础 - aspireSnow | 爱雪
        
    </title>

    <link rel="canonical" href="http://yoursite-url/2018/11/12/redis/redis基础/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('undefined')
            /*post*/
        
    }
    
    #signature{
        background-image: url('/img/signature/BeanTechSign-white.png');
    }
    
</style>

<header class="intro-header">
    <!-- Signature -->
    <div id="signature">
        <div class="container" style="width:1280px;">
            <div class="row">
                <!--
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    -->
                <div class="col-lg-10 col-md-10">    
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#redis" title="redis">redis</a>
                            
                        </div>
                        <h1>redis基础</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by lizhi on
                            2018-11-12
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">aspiresnow</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container" style="max-width:1280px;">
        <div class="row" style="overflow-y:hidden;">

            <!-- Post Container -->
            <!--
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

            <div class="
                col-lg-10
                col-md-11
                post-container">
            -->
            <div class="
                col-lg-10
                col-md-10
                post-container" style="padding-right:10px;">

                <h1><span id="redis基础">redis基础</span></h1>
<p>redis是一个高效的内存数据库，性能极高，读的速度能达到100000次/s,写的速度达到80000次/s</p>
<h2><span id="为什么快">为什么快</span></h2>
<ul>
<li>首先也是最重要的redis所有的数据都存放在内存中</li>
<li>其次redis是C语言实现的，C语言更底层，执行速度相对更快</li>
<li>Redis使用了单线程架构epoll IO多路复用技术，预防了多线程可能产生的竞争和cpu切换问题</li>
</ul>
<p>单线程有个问题，如果某个命令执行过长，会造成其他命令的阻塞，所以redis比较适合高速、高频的访问，避免一个命令返回过多数据，导致执行过慢阻塞。</p>
<p><strong>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</strong></p>
<h2><span id="丰富功能">丰富功能</span></h2>
<p>redi可以作为键值对数据库，主要提供了5种数据结构:<strong>字符串</strong>、<strong>哈希</strong>、<strong>列表</strong>、<strong>集合</strong>、<strong>有序集合</strong>，同时在字符串基础上演变出了<strong>位图(Bitmaps)<strong>和</strong>HyperLog</strong>。除此之外，还额外提供了很多功能</p>
<ul>
<li>键值过期功能，可以用来实现缓存</li>
<li>发布订阅功能，可以用来实现简单消息系统</li>
<li>支持Lua脚本功能，可以利用Lua创造出新的Redis命令</li>
<li>简单的事务功能，能在一定程度上保证事务特性</li>
<li>流水线(Pipeline)功能，支持批量传递命令，减少了网络开销</li>
</ul>
<h2><span id="数据库">数据库</span></h2>
<p>redis在一个实例上提供多个数据库，默认是16个。连接redis默认是用的是 index为0的数据库。一共有0-15个编号的数据库。可以了使用 select 1切换数据库。</p>
<p>redis上各个数据之间数据是相互隔离的。但是由于redis是单线程，一个实例上多个数据仍然使用一个CPU，彼此之间还是会受到影响。所以redis建议一个实例上只使用一个数据库。可如果想要实现多个数据库的功能，完全可以在一台机器上部署多个redis实例。</p>
<h2><span id="执行模式">执行模式</span></h2>
<p><img src="https://image-1257941127.cos.ap-beijing.myqcloud.com/redis/redis%E4%BC%A0%E8%BE%93.png" alt="image"></p>
<p>每次客户端调用都会经历 <strong>发送命令</strong>、<strong>执行命令</strong>、<strong>返回结果</strong> 三个过程。redis是单线程处理的，所以一条命令从客户端到服务端不会立刻被执行，所有的命令都会进入一个队列中，然后逐条执行。由于网络传输无法保证顺序，所以redis无法保证从多个客户端发送的多条命令的执行顺序，但是可以保证不会有两条命令同时被执行。</p>
<h2><span id="全局命令">全局命令</span></h2>
<p>###客户端命令</p>
<h4><span id="启动">启动</span></h4>
<ul>
<li>redis-server : 使用默认配置启动redis，使用默认端口6379</li>
<li>redis-server --configKey1 configValue1 --configKey2 configValue2 :指定配置启动redis</li>
<li>redis-server /xx/xx/redis.conf : 指定配置文件启动redis</li>
<li>redis-server --port 8888 : 指定端口启动redis</li>
</ul>
<h4><span id="连接">连接</span></h4>
<ul>
<li>redis-cli -h ip -p port [Command]: 指定ip和端口连接服务端redis,如果指定了Command 则连接并执行命令
<ul>
<li>redis-cli -h 192.168.2.321 -p 6379</li>
<li>redis-cli -h 192.168.2.321 -p 6379  get hello</li>
<li>redis-cli 连接本地的6379端口的redis</li>
</ul>
</li>
<li>redis-cli shutdown : 停止redis服务,关闭前会生成持久化文件，是一种优雅的关闭</li>
<li>Redis-cli nosave : 关闭，不生成持久化问题</li>
</ul>
<h3><span id="查询">查询</span></h3>
<ul>
<li>
<p>dbsize : 查询redis的键个数，O(1)级别的，不会遍历所有，直接获取变量的值</p>
</li>
<li>
<p>exists key :查询key是否存储 1 存在，0 不存在</p>
</li>
<li>
<p>type key : 查询key的数据结构类型 string、list、hash、set等，键不存在返回none</p>
</li>
<li>
<p>object encoding key : 查询值的内部编码 int、embstr、raw等</p>
</li>
<li>
<p>keys  pattern 命令 : 根据规则遍历redis中的键</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keys * #遍历所有的键</span><br><span class="line"><span class="meta">#</span><span class="bash"> * 代表匹配任意字符</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ? 代表匹配一个字符</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [] 代表匹配部分字符，[a,b]匹配a和b，[1-10]匹配1到10的数字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \x 用来转译 * ?等</span></span><br><span class="line">redis-cli keys a* | xargs redis-cli del #删除a开头的键</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​      由于redis是单线程架构，假如执行 keys命令时查询到了大量的键，执行该命令会很慢，可能会造成redis阻塞，所以不建议在生产环境使用keys命令，redis提供了一种类似分页查询的命令 scan</p>
<ul>
<li>
<p>scan cursor [ MATCH pattern]  [COUNT pagesize] :指定游标(从0开始)，和每次查询数量，每次查询数量默认是10</p>
<p>scan 每次结果都会返回下次查询的起始游标，如果没有数据，返回的游标为 0</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scan 0 MATCH a* COUNT 2 #从0查询a开头的键，每次查询2个</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1) <span class="string">"4"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) 1) <span class="string">"abcd"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    2) <span class="string">"abddd"</span></span></span><br><span class="line">scan 4 MATCH a* COUNT 2 #从上次查询返回游标再次开始查</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1) <span class="string">"0"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) 1) <span class="string">"ab1d"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    2) <span class="string">"abd3d"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询返回的游标为0，证明已经查询完毕</span></span><br></pre></td></tr></table></figure>
<p>使用scan命令可以有效的避免redis可能产生的阻塞问题，但是如果在遍历过程中建发生了增删改，使用scan并不能保证结果的正确性。所有尽量使用scan去遍历一些不会变化的数据</p>
</li>
</ul>
<h3><span id="键过期">键过期</span></h3>
<ul>
<li>
<p>expire key 秒数 : 设置key的n秒后过期</p>
</li>
<li>
<p>expireat key timestamp ：键在<strong>秒级</strong>时间戳timestamp后过期</p>
</li>
<li>
<p>pexpire key 毫秒数 : 设置key在n毫秒后过期</p>
</li>
<li>
<p>pexpireat key timestamp ：键在<strong>毫秒级</strong>时间戳timestamp后过期</p>
</li>
<li>
<p>ttl key : 获取key剩余过期时间 单位为秒</p>
</li>
<li>
<p>pttl key ：获取key剩余过期时间 单位为毫秒</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expire hello 10 #设置 hello的key 10秒后过期</span><br><span class="line">ttl hello # 返回值有以下三种情况</span><br><span class="line"><span class="meta">#</span><span class="bash"> -1 键没有设置过期时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -2 键不存在</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0-n 键剩余过期时间</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>persist key : 清除键上的过期时间</p>
</li>
<li>
<p>对于字符串类型的键，执行set命令也会清除键的过期时间，所以redis提供了原子性命令 <strong>setex = set+expire</strong></p>
</li>
</ul>
<h3><span id="删除">删除</span></h3>
<ul>
<li>del key [key1 key2 …] :删除键，支持一次删除多个键，返回删除键的个数</li>
<li>flushdb : 清空当前redis数据库</li>
<li>flushall : 清空redis实例上所有的数据库</li>
<li>rename key newkey ：重命名key，会覆盖已经存在的newkey</li>
<li>renamenx key newkey : 重命名key，当newkey已经存在的时候返回 0，重命名失败</li>
</ul>
<h3><span id="数据迁移">数据迁移</span></h3>
<ul>
<li>
<p>move key db : 在一个redis实例的多个数据库之间迁移数据</p>
</li>
<li>
<p>dump + restore : 复制字节码值  — 存储字节码值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dump key  # 在一台redis服务器上执行该命令 会打印出 value值</span><br><span class="line">restore key 过期时间 value # 在另一台服务器上 将复制的key和value 再存储上</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>migrate host port key|&quot;&quot; dest-db timeout [copy] [replace] [key1 key2 key3…]</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> host port 目标redis的ip和端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> key|<span class="string">""</span> 如果要迁移一个键，直接指定key值，如果迁移多个键，这使用 <span class="string">""</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dest-db 目标redis的数据库编号 ，一般默认使用0的数据库，所以这一般写0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> timeout 迁移的超时时间 单位为毫米</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [copy] 如果写了copy,迁移后并不删除源键</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [replace] 如果写了replace，会覆盖目标redis上相同建的值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [key1 key2 ...] 迁移多个键的时候用，前面没有指定键，使用的是 <span class="string">""</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2><span id="数据结构">数据结构</span></h2>
<h3><span id="字符串string">字符串string</span></h3>
<p>字符串类型的key都是字符串，值可以是字符串、整型、浮点型、二进制，值最大不能超过512mb。</p>
<h4><span id="1内部编码">1.内部编码</span></h4>
<p>字符串类型的内部编码有3种</p>
<ul>
<li>int : 8个字节的长整型</li>
<li>embstr : 小于等于44个字节的字符串</li>
<li>raw : 大于44个字节的字符串</li>
</ul>
<h4><span id="2命令">2.命令</span></h4>
<ul>
<li>
<p>set key value [ex seconds] [px millseconds] [nx|xx] ： 更新创建一个key，并设置过期时间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ex seconds 可选，为键设置秒级过期时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> px seconds 可选，为键设置毫秒级过期时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nx 可选，键必须不存在，才可以设置成功，用于新增</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xx 可选，键必须存在，才可以设置成功，用于更新</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>setnx key value ：  键不存在创建一个key，原子性的命令</p>
</li>
<li>
<p>setex key value seconds : 创建一个key，并设置过期时间，原子性的命令</p>
</li>
<li>
<p>get key ： 获取指定键的值</p>
</li>
<li>
<p>mset key [key1 key2…]  : 批量设置值</p>
</li>
<li>
<p>mget key [key1 key2…] : 批量获取一堆key的值，顺序返回，键不存在会返回 (nil)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用单个命令耗时： n次get\set的时间 = n次网络时间 + n次命令时间</span><br><span class="line">使用批量命令耗时:  n次get\set的时间 = 1次网络时间 + n次命令时间</span><br><span class="line">使用批量命令能有效的提供访问速度，但是如果一次操作太多的key，可能会导致redis阻塞。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>incr key ：对于值为整型的key 进行原子加一操作,返回自增后的结果。如果key不存在，值按照0为自增为1</p>
</li>
<li>
<p>decr key :  -1操作</p>
</li>
<li>
<p>incrby key n ：指定自增数字</p>
</li>
<li>
<p>decrby key n ：指定自减数字</p>
</li>
<li>
<p>incrbyfloat key n ：指定自增浮点数</p>
</li>
<li>
<p>append key value : 向字符串尾追加值</p>
</li>
<li>
<p>strlen key : 查询值的字节长度</p>
</li>
<li>
<p>getset key value : 设置新的值返回原来的值</p>
</li>
<li>
<p>setrange key offset value : 设置指定位置的字符</p>
</li>
<li>
<p>getrange key start end : 获取指定范围的值的字符，包含首尾</p>
</li>
</ul>
<p>字符串类型的键的命令操作除了批量的操作，复杂度基本都是O(1)级别的，批量操作的命令复杂度是O(n)级别的(n为操作的key的个数)。所以字符串类型的命令操作特别快</p>
<h4><span id="3应用场景">3.应用场景</span></h4>
<ul>
<li>验证码缓存 : 生成的验证码添加到缓存中并设置过期时间，这样重复获取的时候直接从缓存中获取</li>
<li>计数 : 利用redis的原子性计数功能实现简单的库存控制</li>
<li>流控 : 利用原子计数和过期控制的功能，实现流控，控制接口在单位时间内的访问次数</li>
</ul>
<h3><span id="哈希hash">哈希hash</span></h3>
<p>hash类指的是value本身是一种键值对的结构，key : {name:zhangsan,age:18},这种格式能够方便的操作对象类的数据格式</p>
<h4><span id="1内部编码">1.内部编码</span></h4>
<ul>
<li>ziplist : ziplist比较节省内存，但是读写效率相对较低。当该key对应的值的field个数小于配置 hash-max-ziplist-entries(默认512)配置，同时所有field对应的值大小都小于hash-max-ziplist-value(默认64字节)配置时，使用ziplist。</li>
<li>hashtable : 当无法满足ziplist的条件时，内部编码会由ziplist转为hashtable。hashtable读写复杂度O(1)</li>
</ul>
<h4><span id="2命令">2.命令</span></h4>
<p>hash类型的命令跟字符串类型的基本一致，只是hash类型的命令更多的是针对field的操作，而且每个命令前都会加个<code>h</code></p>
<ul>
<li>hset key field value : 创建设置指定key指定field的值</li>
<li>Hsetnx key field value : field不存在的时候set成功</li>
<li>hget key field : 获取指定key指定field的值</li>
<li>hdel key field [field1 field2 …] :  删除一个或者多个field，返回成功删除field的个数</li>
<li>hlen key : 计算指定key的field的个数</li>
<li>hexists key field : 判断field是否存在,1 存在，0 不存在</li>
<li>hmset key field [field1 field2 …] : 批量设置field的值</li>
<li>hmget key field [field1 field2 …] : 批量获取field的值</li>
<li>hgetall key : 获取所有的 field-value</li>
<li>hkeys key : 获取指定key下所有的field</li>
<li>hvals key : 获取所有field对应的value</li>
<li>hstrlen key field : 计算field值的字节长度</li>
<li>hincrby key field n: 对field的值进行自增n，注意值必须是整型</li>
<li>hincrbyfloat key field n : 对field的值进行浮点数加</li>
</ul>
<p><strong>hash类型的field无法单独设置过期时间，过期的作用域只能是key</strong>。hash类型的命令简单的操作复杂度都是O(1)级别的，批量操作和hkeys、hvals、hgetall 操作复杂度为 O(n)  n为field的总数，</p>
<h4><span id="3应用场景">3.应用场景</span></h4>
<p>hash类型的值存的是一个对象，相比较字符串类型，hash类型可以减少key的数量，key多了也是会消耗内存的。<br>
如果缓存值是一个对象，并且针对该值的操作更多的是针对对象中的字段单独进行操作时，建议使用hash类型来存储。</p>
<h3><span id="列表list">列表list</span></h3>
<p>列表类型是有序的字符串集合，列表中可以含有重复的元素，一个列表最多存储 2的32次方-1个元素</p>
<h4><span id="1内部编码">1.内部编码</span></h4>
<ul>
<li>ziplist : 当该key对应的列表的元素个数小于 list-max-ziplist-entries(默认512)配置，并且列表中每个元素的值都小于 list-max-ziplist-value(默认64字节)配置时，使用ziplist，用于节省内存空间</li>
<li>linkedlist : 当列表中元素无法满足ziplist的条件时，会将ziplist类型转换为linkedlist提高读写效率。</li>
</ul>
<h4><span id="2命令">2.命令</span></h4>
<p>列表类型是一个<strong>双向</strong>的数组，对于列表的操作命令跟操作java中的list类似，所有的命令前都会加 <code>l</code>或者<code>r</code></p>
<ul>
<li>
<p>lrange key start end : 查询列表中元素，需要指定start和end</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">索引下标有两个特点 lrange key 0 -1 查询所有的元素</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 索引下标从左到右 分别是 0 到 n-1，从右往左分别是 -1 到 -n。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lrange 查询出来的结果是包含首尾的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>lpush key value [value1 value2…]  : 左侧插入元素 O(n) n为元素个数</p>
</li>
<li>
<p>rpush key value [value1 value2…]  : 右侧插入元素 O(n) n为元素个数</p>
</li>
<li>
<p>linsert key before|after preValue value : 找到preValue元素，然后在其前或者后插入元素 O(n) n为挪动的元素个数</p>
</li>
<li>
<p>lindex key index : 获取列表中指定索引下标的元素 O(n) n为索引的偏移量</p>
</li>
<li>
<p>lset key index newValue : 修改指定索引下标的元素值 O(n) n为索引的偏移量</p>
</li>
<li>
<p>lpop key  : 弹出列表最左侧元素，返回该元素 O(1)</p>
</li>
<li>
<p>rpop key  : 弹出列表最右侧元素，返回该元素 O(1)</p>
</li>
<li>
<p>llen key : 获取列表的长度 O(1)</p>
</li>
<li>
<p>lrem key count value : 删除元素，count是要删除值为value的元素的个数  O(n) n为列表长度</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> count &gt; 0，从左到右，删除最多count个值为value的元素</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count &lt; 0，从右到左，删除最多count个值为value的元素</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count = 0, 删除所有值为value的元素</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ltrim key start end : 只保留start和end范围的元素列表 O(n) n为要裁剪的元素总数</p>
</li>
<li>
<p>blpop key [key1 key2…] timeout : 阻塞式弹出 O(1)</p>
</li>
<li>
<p>brpop key [key1 key2…] timeout</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> key [key1 key2] : 指定了多个键，只要有一个键对应的列表中有元素就可以弹出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> timeout 阻塞时间，单位为秒，timeout=0表示一直阻塞，直到有元素弹出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> timeout 指定了大于0的值 n 时</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 该时间范围内有元素添加，直接弹出</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 该时间范围内无元素添加，到了阻塞时间 n，直接返回 (nil)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4><span id="3应用场景">3.应用场景</span></h4>
<ul>
<li>栈 : lpush + lpop</li>
<li>队列 : lpush + rpop</li>
<li>消息队列 : 使用lpush + brpop 实现阻塞队列，生产者lpush，多个消费者阻塞获取。</li>
<li>有限集合 : lpush + ltrim</li>
</ul>
<h3><span id="集合set">集合Set</span></h3>
<p>set类型跟list类型一样都是一个数组，set是无序并且不允许有重复元素，无法通过下标获取元素。set支持多个集合之间的交集、并集、差集的命令运算。</p>
<h4><span id="1内部编码">1.内部编码</span></h4>
<ul>
<li>intset : 当集合中元素都是整数并且元素个数小于 set-max-intset-entries (默认512个)配置时，选用intset作为集合的编码实现，用于节省内存空间</li>
<li>hashtable : 当集合没有满足intset的条件时，将intset类型转换为hashtable类型，提高读写效率</li>
</ul>
<h4><span id="2命令">2.命令</span></h4>
<p>操作set的命令跟操作java中的set类似，所有的命令都以 <code>s</code>开头</p>
<ul>
<li>smembers key : 获取集合中所有的元素</li>
<li>sadd key value [value1 value2…] : 添加元素,返回成功添加的元素个数 O(n) n为元素的个数</li>
<li>srem key value [value1 value2…] : 删除元素,返回成功删除的元素个数 O(n) n为元素的个数</li>
<li>scard key : 计算集合中元素的个数 O(1)</li>
<li>sismember key value : 判断元素是否在集合中 在返回1，不在返回0, O(1)</li>
<li>srandmember key [count] : 随机从集合中返回指定个数的元素，默认1 , O(count)</li>
<li>spop key [count]: 从集合中随机弹出元素,返回被弹出的元素 O(count)</li>
<li>sinter key [key1 key2…] : 求多个集合的交集  O(m*k) m为键个数，k为集合中元素最少的个数</li>
<li>sunion key [key1 key2…] : 求多个集合的并集  O(n) n为多个集合的元素数总和</li>
<li>sdiff key [key1 key2…] : 求多个集合的差集  O(n) n为多个集合的元素数总和</li>
<li>sinterstore destKey key [key1 key2…] : 将交集保存到destKey中</li>
</ul>
<h4><span id="3应用场景">3.应用场景</span></h4>
<p>set类型的数据结构应用场景更多是对多个集合之间做并、交、差集进行操作。当业务场景需要用到多个key集合之间做这些用算的时候，使用set会很方便。</p>
<p>例如求不同用户之间相同的兴趣爱好，可以使用set类型，userId做key，然后将兴趣爱好存到set中，使用set的sinter方法求多个用户兴趣爱好的交集。</p>
<h3><span id="有序集合sortedset">有序集合sortedSet</span></h3>
<p>有序集合在集合set的基础上对每个元素设置了一个分数，根据分数可以对集合中的元素进行排序。有序集合中的元素同集合set一样不能重复，但是分数可以一样。</p>
<h4><span id="1内部编码">1.内部编码</span></h4>
<ul>
<li>ziplist : 当有序集合的元素个数小于 zset-max-ziplist-entries(默认128)配置，并且集合中每个元素的值都小于 zset-max-ziplist-value(默认64字节)配置时，使用ziplist，用于节省内存空间</li>
<li>skiplist : 当集合中元素无法满足ziplist的条件时，会将ziplist类型转换为skiplist提高读写效率。</li>
</ul>
<h4><span id="2命令">2.命令</span></h4>
<ul>
<li>
<p>zrange key start end [withscores] : 从低到高区间返回，withscores是带分数返回</p>
</li>
<li>
<p>zrange key start end [withscores] : 从高到低区间返回，withscores是带分数返回</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">索引下标有两个特点 zrange key 0 -1 查询所有的元素</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 索引下标从左到右 分别是 0 到 n-1，从右往左分别是 -1 到 -n。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zrange 查询出来的结果是包含首尾的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>zrangebyscore key min max [withscores] [limit offset count]:按照分数从低到高，limit可以限制输出的起始位置和个数</p>
</li>
<li>
<p>zrevrangebyscore key max min [withscores] [limit offset count]:按照分数从高到底</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> min 和 max支持开区间(小括号)，-inf和+inf分辨代表无穷小和无穷大</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zrangebyscore zkey (2 +inf withsocres</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zrangebyscore zkey (2 (5 withsocres</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>zadd key score member [score member …] :向sortedSet中添加元素，并指定分数，时间复杂度 O(log(n))</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nx : member必须不存在，才可以设置成功，用于添加</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xx : member必须存在，才可以设置成，用于更新</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ch : 返回此次操作后，有序集合元素和分数发生变化的个数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> incr : 当member存在的时候，是更新分数累加，当member不存在的时候，是对分数进行赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>zcard key : 计算成员个数 O(1)</p>
</li>
<li>
<p>zcount key min max : 返回指定分数范围成员个数</p>
</li>
<li>
<p>zscore key member : 获取某个元素的分数，成员不存在返回nil</p>
</li>
<li>
<p>zrank key member : 按分数从低到高返回member的排名,从0开始</p>
</li>
<li>
<p>zrevrank key member : 按分数从高到低返回member的排名，从0开始</p>
</li>
<li>
<p>zrem key member [member …] : 删除成员元素</p>
</li>
<li>
<p>zremrangebyrank key start end : 删除指定排名内的升序元素</p>
</li>
<li>
<p>zremrangebyscore key min max : 删除指定分数范围的元素，返回成功删除的个数</p>
</li>
<li>
<p>zincrby key increment member : 增加成员的分数，increment是分数的点数</p>
</li>
<li>
<p>zinterstore destination numkeys key [key1 …] [weights weight [weight …]] [aggregate sum|min|max] : 交集</p>
</li>
<li>
<p>zunionstore destination numkeys key [key1 …] [weights weight [weight …]] [aggregate sum|min|max] : 并集</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> destnation:需指定，计算结果保存到的那个键</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> numkeys : 需指定，需要做集合运算的key的个数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> key [key...] : 需指定，做集合运算的sortedset类型的键</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> weights weight [weight ...] :每个键占的权重，做集合运算时，每个键中的元素的分数乘于自己对应的权重</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> aggregate sum|min|max: 聚合策略，集合运算后，对相同的元素做聚合处理的策略</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4><span id="3应用场景">3.应用场景</span></h4>
<ul>
<li>排行榜系统 ：通过分数来控制排序</li>
</ul>
<h2><span id="持久化">持久化</span></h2>
<p>内存中的数据是不安全的，一旦发生断电或者机器故障，数据就会丢失，因此Redis提供了两种持久化方式，用于将内存中的数据保存到磁盘中</p>
<ul>
<li>RDB</li>
<li>AOF</li>
</ul>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/11/12/redis/redis慢命令分析/" data-toggle="tooltip" data-placement="top" title="redis慢命令分析">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2018/10/29/spring/spring-AOP/" data-toggle="tooltip" data-placement="top" title="spring-AOP">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
             <!-- Table of Contents -->
 
  <aside id="sidebar" class="post-container">
    <div id="toc" class="toc-article">
    <!-- mytoc -->
    <div class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix-top" style="top:20px;" role="complementary">
        <h4><i class="fa fa-bookmark"></i> Catalog</h4>
        <ul class="nav bs-docs-sidenav">

        </ul>

    </div>
    </div>
  </aside>

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#redis" title="redis">redis</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>




<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "your-disqus-ID";
    var disqus_identifier = "http://yoursite-url/2018/11/12/redis/redis基础/";
    var disqus_url = "http://yoursite-url/2018/11/12/redis/redis基础/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank" href="https://github.com/aspiresnow">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; lizhi 2019 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://beantech.org">BeanTech</a> | 
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite-url/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://yoursite-url/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
